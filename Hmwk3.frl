% This is a dummy file used because I got tired of typing reload AsdfhEshdiCasdhAss3.frl in all the time

/*
Authors:
    Foertmeyer, Thomas
    Li, Kendrick
    Okel, Taylor
Date:
    10 October 2016
*/

/*
Description:
    A knowledge constraint problem. Consider the following logic puzzle:
        In five houses, each of a different color, live five persons, each of a different 
        nationality, each of whom prefers a different brand of candy, a different kind of pet,
        and a different drink.
*/

/* SUMMARY
=============================================================================================================================================
 In five houses, each of a different color, live five persons, each of a different 
 nationality, each of whom prefers a different brand of candy, a different kind of pet,
 and a different drink.

 The Englishman lives in the red house.
 The Spaniard owns the dog.
 The Norwegian lives in the first house on the left.
 The green house is immediately to the right of the ivory house.
 The man who eats Hershey-bars lives in the house next to the man with the fox.
 Kit-Kats are eaten in the yellow house.
 The Norwegian lives next to the blue house.
 The Smarties eater owns snails.
 The Snickers eater drinks orange juice.
 The Ukrainian drinks tea.
 The Japanese eats Milky-Ways.
 Kit-Kats are eaten in a house next to the house where the horse is kept.
 Coffee is drunk in the green house.
 Milk is drunk in the middle house
 
 Write a FRIL program which would allow you to implement this KB and allow you to answer various questions such as:
What color is the house in which the Norwegian lives?
What color is the house in which the zebra lives?
In which house is wine drank?
In which house are Smarties eaten and orange juice drank?
What color is the fifth house (last house on the right)?
Who drinks what?
Etc.
 
If a query cannot be answered directly from the knowledge base, your program should generate possible answers.  
For example, suppose the query is “who drinks water?”  The knowledge base contains no clause on anybody drinking water.  
Rather than let the query fail, the program should output possible answers, for example “nobody drinks water”, 
	or, eliminating those for which it can find what they drink, display the answer in the format “possibly <nationality> drinks water”.
	
Please turn in your program, along with a sample of runs attached to your program file as comments.
==============================================================================================================================================
*/

/* Build Database */
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
((order First))
((order Second))
((order Third))
((order Fourth))
((order Fifth))

((nation Englishman))
((nation Spaniard))
((nation Norwegian))
((nation Ukrainian))
((nation Japanese))

((color Red))
((color Yellow))
((color Green))
((color Ivory))
((color Blue))

((drink Milk))
((drink OrangeJuice))
((drink Tea))
((drink Coffee))

((candy Kit-Kats))
((candy Smarties))
((candy Snickers))
((candy Hershey-bars))
((candy Milky-Ways))

((pet Fox))
((pet Dog))
((pet Snails))
((pet Horse))

/* Set up known connections */
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

((connect Englishman Red))
((connect Spaniard Dog))
((connect Norwegian First))
((connect Ukrainian Tea))
((connect Japanese Milky-Ways))
((connect Kit-Kats Yellow))
((connect Smarties Snails))
((connect Snickers OrangeJuice))
((connect Milk Third))
((connect Green Coffee))

/* TODO need to generate these logically.  I generated these manually */
% Norwegian lives next to blue
    % since Norwegian is first, the only guy next to first is second
((connect Blue Second))
% Green house is immediately right of ivory
    % (Y B ((R I G) or (I G R))
    % since Norwegian is first, he can't be Red (Englishman), Blue (Second), Green (Ivory can't be on left), or Ivory (right is Blue)
((connect Norwegian Yellow))
% Kit-Kats dude is next to horse guy
    % Norwegian is Yellow now, so he eats Kit-Kats, which means horse must be Second
((connect Horse Second))
% Hershey-bars dude lives next to fox guy
    % IDK

((relation Norwegian Blue Next))
((relation Green Ivory Right))
((relation Kit-Kats Horse Next))
((relation Hershey-bars Fox Next))

/* AUX MEMBERS */
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
((append () L L))
((append (H|T) L2 (H|L))(append T L2 L))

((member H (H|_)))
((member X (H|T))(member X T))

((connected A B)(connect A B))
((connected A B)(connect B A))

((left First Second))
((left Second Third))
((left Third Fourth))
((left Fourth Fifth))

((right A B)(left B A))

((adjacent A B)(left A B))
((adjacent A B)(right A B))

((between A B C)
    (left A C)
    (right B C)
)
((between A B C)
    (left B C)
    (right A C)
)

% Fit into variables
((makeconnect)
	(connected B 'Ivory')
	(right A B)
	(addcl ((connect Green A)))
	(!)
	(fail) % send into subsequent makeconnect clauses
)
((makeconnect )
	(connected Fox NUM)
	(order NUM)
	(adjacent NUM TARGET)
	(connect TARGET CANDY)
	(negg candy CANDY)
	(addcl ((connect Hershey-bars B)))
	(!)
	(fail)
)

?((makeconnect))

/*PSUEDO CODE FOR TALOR SEARCH
******************************************
?((search <dict> <clause> RESULTS))
	Where <dict> is a dictionary (e.g. color) element to search for
		TODO: what about general "house"?
			- use "HOUSE", return all results as a list in house?
	And <clause> is the search clause (e.g. "in which the Norwegian lives")
	RESULTS will hold the result(s).
		IF length == 0, no potential answer was found.
		IF length == 1, an exact match was found.
		IF length > 1, multiple matches were found -- display "potential" answer
		EXCEPT for the general house case (unless we decide that "house" refers to order?)

~
	
IF <dict> is a type
	Search all connections off of <clause> for type dict
		IF none, return "Nobody ___"
			OR find inverse of the taken <dict> set, return these possibilities
		IF one, return answer
		IF multiple, return "Possibly ___" for all answers
ELSE
	Search all connections off of <clause>
		IF none, return "Nobody ___"
			OR find inverse of the taken sets, return those as possibilities
******************************************
*/

/* SEARCH PREDICATES */
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*PSUEDO CODE FOR KENDRICK SEARCH
******************************************
((search <root> <goal>))
    Begins a search where root is the root starting attribute string and goal is the goal attribute string
    Create a ((goal <goal>)) clause
    Begin the innerSearch with (<root>) as the first element to search
    IF innerSearch FAILS
        We could not find the goal
        Cleanup and fail
    ELSE
        Goal was found and printed
        Cleanup
    
(innerSearch <search list> <searched list> <full graph>)
    IF <search list> is empty, we have gone through the entire map and we were not able to find the goal
        Stop further execution
        Save <full graph> as <searched list>
        Fail the clause
    ELSE IF goal is the head of <search list>
        Goal is connected to Root so they are connected!
        Print goal and succeed (search will stop because we succeeded)
    ELSE
        Remove the head of <search list> <head> and append it to the <searched list>
        Append all children of <head> that hasn't been searched (does not exist in <searched list>) into search list
        Search on <search list> again
        
innerSearch will continue to search on <search list> until either the goal is found or if there are no more nodes to search on

******************************************/

((search R G)                                           % Begin search on Root to Goal
    (kill goal)
    (addcl ((goal G)))
    (innerSearch (R) () FG)                             % run inner search function
    (var FG)                                            % if FG is uninit, that means that we didn't fail 
    (delcl ((goal G)))                                  % cleanup
)
((search _ _)                                           % If first clause failed, we didn't find anything
    %(pp (did not find goal))
    (delcl ((goal G)))                                  % cleanup
    (fail)
)

((innerSearch () FG FG)                                 % If the search list is empty, we didn't find anything
    (!)                                                 % cut and assign the full graph to the full graph var on right
)
((innerSearch (H | _) _ _)                              % If the head is the goal, print goal and exit
    (goal H)
    (pp H)
)
((innerSearch (H | T) SL FG)                            % We checked H and it's not the goal,
    (append (H) SL SEARCHED)                            % so append H to the top of FullGraph and save into SEARCHED
    (findall CHD                                        % Find all Child,
        ((connected H CHD)(negg member CHD SEARCHED))   % that is connected to H and not searched before,
        CDN                                             % and save into a list Children
    )
    (append T CDN LIST)                                 % append CDN to the end of the rest of the search list and save into LIST
    (innerSearch LIST SEARCHED FG)                       % search again on LIST with updated searched list
)

% Returns full graph of R
((fullGraph R FG)
    (innerSearch (R) () FG)
)

/* FIND PREDICATES */
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Finds the house order for an ATTribute (ex. which house does the [ATT]Snickers owner live in?)
((findOrder ATT)
    (order ORD)
    (search ATT ORD)
)
((findOrder ATT)                                        % First clause failed completely, so no order found for ATT
    (pp (order not found for ATT))
    % TODO, to return a list of possible orders, for each order...
    % get the full graph
    % if the full graph does not contain a type of ATT, add order to <possibilities>
    % once through with each order, <possibilities should contain a list of possible orders>
    
    % Need to get a predicate to return what type something is and a predicate to search the 
    % full graph for that type
)

% Finds the nationality for an ATTribute (ex. which nationality is the [ATT]Snickers owner?)
((findNation ATT)
    (nation NAT)
    (search ATT NAT)
)
((findNation ATT)                                       % First clause failed completely, so no nation found for ATT
    (pp (nation not found for ATT))
)

% Finds the house color for an ATTribute (ex. what color is the house that the [ATT]Snickers owner lives in?)
((findColor ATT)
    (color COL)
    (search ATT COL)
)
((findColor ATT)                                        % First clause failed completely, so no color found for ATT
    (pp (color not found for ATT))
)

% Finds the beverage for an ATTribute (ex. what beverage does the [ATT]Snickers owner drink?)
((findDrink ATT)
    (drink BEV)
    (search ATT BEV)
)
((findDrink ATT)                                        % First clause failed completely, so no beverage found for ATT
    (pp (drink not found for ATT))
)

% Finds the candy for an ATTribute (ex. what candy does the [ATT]Snickers owner eat?)
((findCandy ATT)
    (candy CAN)
    (search ATT CAN)
)
((findCandy ATT)                                        % First clause failed completely, so no candy found for ATT
    (pp (candy not found for ATT))
)

% Finds the pet for an ATTribute (ex. what pet does the [ATT]Snickers owner own)
((findPet ATT)
    (pet PET)
    (search ATT PET)
)
((findPet ATT)                                          % First clause failed completely, so no pet found for ATT
    (pp (pet not found for ATT))
)
