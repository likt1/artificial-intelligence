% Taylor Okel
% Kendrick Li
% Tommy Foertmeyer
% AI Homework 4

% SUMMARY
% In this program you are to implement in FRIL a small theorem prover for propositional logic. 
% You will need to implement a predicate called roi (from rule of inference) 
% for each of the rules of inference for propositional logic.  
% These rules are to be used conjunction with a knowledge base in at most two inference steps. 

% KNOWLEDGE BASE
% Provided by user. User should specify ((given X)), e.g. ((given p)), ((p or q)) -> yes

% Destruct KB
?((dict X)(kill X)(fail))
((destroyKB)(kill known)(kill conclusion)(kill step))


((buildKB ()))
((buildKB (H | T))
	(addcl ((known H)))
	(buildKB T)
)

((buildSteps ()))
((buildSteps (H | T))
	(addcl ((step H)))
	(buildSteps T)
)

((check)
   (conclusion CONCLUSION)
   (known CONCLUSION)
)

((addtoKB (A|_) )
   (length A N)
   (less 1 N)
   (!)
   (negg known A)
   (addcl ((known A)))
)
((addtoKB A)
   (length A N)
   (eq 1 N)
   (!)
   (negg known A)
   (addcl ((known A)))
)

% For Backwards Chaining
% For a knowledge base of TYPE, try different Rules of Inference (roi) to infer new values.
%

((infer TYPE)
	(known CLAUSE)
	(rule RULE)
	(roi RULE TYPE CLAUSE RESULT)
	(negg known RESULT)
	(addcl ((known RESULT)))
	(addcl ((step RULE)))
)

% For forward chaining
((infer2 TYPE)
	(step STEP)
	(known CLAUSE)
	(roi STEP TYPE CLAUSE RESULT)
	(negg known RESULT)
	(addcl ((known RESULT)))
)

% Backward Chaining
((small_prover TYPE PREMISES CONCLUSION STEPS)
	(var STEPS)
	(destroyKB)
	(addcl ((known PREMISES))) % Preserve initial premises. Could be useful with AndIntroduction
	(buildKB PREMISES)  
	(addcl ((conclusion CONCLUSION)))
	(infer TYPE)
	(check)  
)
((small_prover TYPE PREMISES CONCLUSION STEPS)
	(var STEPS)
	(destroyKB)
	(addcl ((known PREMISES))) % Preserve initial premises. Could be useful with AndIntroduction
	(buildKB PREMISES)  
	(addcl ((conclusion CONCLUSION)))
	(infer TYPE)
	(infer TYPE)  
	(check)
)

% Forward Chaining
((small_prover TYPE PREMISES CONCLUSION STEPS)
	(var CONCLUSION)
	(destroyKB)
	(addcl ((known PREMISES))) % Preserve initial premises. Could be useful with AndIntroduction
	(buildKB PREMISES)
	(buildSteps STEPS)
	(infer2 TYPE)
	(infer2 TYPE)
	(list step)
)
((small_prover TYPE PREMISES CONCLUSION STEPS)
	(var CONCLUSION)
	(destroyKB)
	(addcl ((known PREMISES))) % Preserve initial premises. Could be useful with AndIntroduction
	(buildKB PREMISES)
	(buildSteps STEPS)
	(infer2 TYPE)
	(list step)
)

% Modified from small_prover.frl

((roi UnitResolution  cnf ((A or B)) (A))
   (known (~ B))
)
((roi UnitResolution  cnf (A or B) (A))
   (known (~ B))
)
((roi UnitResolution  cnf ((A or B)) (B))
   (known (~ A))
)
((roi UnitResolution  cnf (A or B) (B))
   (known (~ A))
)

((roi UnitResolution  inf   ((~ A) imp B) (A))
   (known (~ B))
) 


((rule UnitResolution))
((rule deMorgan))
((rule AndElimination))
((rule AndIntroduction))
((rule ModusPonens))

((roi ModusPonens inf ((A imp B)) (B))
	(known (A))
)
((roi ModusPonens inf (A imp  B) (B))
	(known (A))
)
((roi ModusPonens inf ((A imp B) (A)) (B)))

/*************** The following is from small_prover.frl *********/

% ((roi NAME  TYPE PREMISES CONCLUSION)) 
% Holds if the rule of inference with name NAME and premises PREMISES written in TYPE (cnf or inf)
% can be used to infer CONCLUSION.


((roi UnitResolution  cnf ((A or B) (~ B))  A)) 
((roi UnitResolution  cnf ((A or B) (~ A))  B)) 



% or, in implicative form: 

((roi UnitResolution  inf  ( ( (~ A) imp B) (~ B))  A)) 

((roi AndElimination _ ((A and | T)) A)) 
((roi AndElimination _ ((A and | T )) B)(member B T)) 

((roi AndIntroduction _ () ())) 
((roi AndIntroduction _  (A | T) ( A and | T1) ) 
     (negg member_op OP T) 
     (roi AndIntroduction _ T T1)) 

((operators (and or imp ~))) 
((member_op L)(operators OPS )(member OP OPS)) 

% De Morgan's Rules (some of the clauses): 
((deMorgan () ())) 

% This was written by Taylor
((roi deMorgan cnf ((~ (A and B) )) ((~ A) or (~ B)))) 
((roi deMorgan cnf ((~ (A and B and | T) )) ((~ A) or (~ B) or T1))
	(deMorgan (~ T) T1)(!)) 

% This was written by Taylor
((roi deMorgan cnf ((~ (A or B) )) ((~ A) and (~ B)))) 
((roi deMorgan cnf ((~ (A or B or | T) )) ((~ A) and (~ B) and T1))
	(deMorgan (~ T) T1)(!)) 
((roi deMorgan cnf ((~ (A and B or | T) )) ((~ A) or (~ B) and T1))
	(deMorgan (~ T) T1)(!))

((roi deMorgan cnf ((~ (A or B and | T) )) ((~ A) and (~ B) or T1))
	(deMorgan (~ T) T1)(!)) 
((roi deMorgan cnf (~ (A)) (~ A)))

/************ End small_prover.frl ******************************/

/************* The following is from list_pro.frl ***************/

((member H (H|_)))  %the head of a list is an element of that list

((member E ( _| T ))                              
	    		%  otherwise, E is an element of the list if it
      (member E T))     % is an element of its tail 



/*
(length LIST N) holds when N is the length of (number of elements in)
 the list LIST:

    The length of a non empty list is 1 + length of its tail;
    The length of an empty list is 0. 
    The length predicate makes use of the built in predicate sum  (sum X Y Z) holds when it is true 
    that X+Y is equal to Z

*/

((length () 0 ))
((length (_|T) N)
           (length T N1)
           (sum N1 1 N))




/*
(apppend L1 L2 L) holds if L is the list L1 followed by the list L2 .
To write this predicate we note the following: 

    the head of L is the same as the head of L1
    the tail of L is the tail of L1 followed by L2

*/



((append () L L))  %when L1 is () L is the same as L2 

((append (H1|T1) L2 (H1|T))
            (append T1 L2 T))

%using append to define member
((member_append E L)
             (append _ (E|_) L))
